\n{1}{Analýza aplikace}

Tato kapitola se zabývá analýzou aplikace z hlediska vývoje, výstupu a výkonu. Využívá k tomu definovanou metodiku a scénáře testování. Výsledky jsou důkladně analyzovány a závěry shrnuty v jednotlivých sekcích.

\n{2}{Architektura}

Výsledná architektura aplikace je založena na mikroslužbách. Splňuje předem definované funkční a nefunkční požadavky. V případě testovaných služeb, zapojuje základní množinu systémových knihoven a knihoven 3. stran. Po straně telemetrie, implementuje sběr a zpracování dat z různých zdrojů. Výsledná data jsou následně zpracována a uložena do databáze, dle druhu dat. Veškeré dostupné zdroje jsou uživatelsky přívětivě vizualizovány v rámci webového aplikace Grafana. Aplikační stack je testovatelný a nasaditelný na všech hlavních platformách (po sestavení se zacílením na vybranou architekturu a využitím variant služeb třetích stran s cílovou architekturou).


\n{2}{Vývojový proces}

Následující sekce popisuje vývojový proces, tak jak se týkal testovaných služeb. Vývojový proces byl založen na experimentaci a snaze využít co nejvíc dostupných knihoven a nástrojů, za cenu nutnosti řešení problémů, případně změny implementace.

\n{3}{JIT}

Vývojový proces pro kompilaci služeb JIT se zacílením na .NET runtime probíhal standarntím způsobem. Veškeré dostupné knihovny a nástroje byly plně kompatibilní s JIT kompilací. Nedošlo k žádným nepředpokládaným problémům.

Znatelný rozdíl oproti běžnému vývoji byl výběr technologií, který přihlížel k potencionální kompatibilitě s AOT a tedy řešení, které inherntně vyžadovala funkce rezervované pro využití .NET runtime, byly ihned zavrženy.

\n{4}{Výhody}

Mezi hlavní výhody se řadí zprostředkování následujícího:

\begin{itemize}
    \item  \textbf{Reflexe} - CLR umožňuje využívat reflexi, která umožňuje získat informace o kódu za běhu aplikace. Tímto je umožněno vytvářet aplikace, které jsou schopny měnit své chování za běhu.
    \item \textbf{Dynamické načítání} - CLR umožňuje dynamicky načítat knihovny za běhu aplikace. Tímto je umožněno vytvářet aplikace, které jsou schopny měnit své chování za běhu.
    \item \textbf{Větší bezpečnost} - CLR zajišťuje, že aplikace nemůže přistupovat k paměti, která jí nebyla přidělena. Tímto je zajištěna bezpečnost aplikace a zabráněno chybám, které by mohly vést k pádu aplikace.
    \item \textbf{Správa paměti} - CLR zajišťuje správu paměti pomocí GC. Tímto je zajištěno, že paměť je uvolněna vždy, když ji aplikace již nepotřebuje. Tímto je zabráněno tzv. memory leakům, které by mohly vést k pádu aplikace.
    \item \textbf{Větší přenositelnost} - CLR zajišťuje, že aplikace je spustitelná na všech operačních systémech, na kterých je dostupné běhové prostředí CLR.
\end{itemize}

\n{4}{Nevýhody}

Zatímco za nevýhody CLR se dá považovat:

\begin{itemize}
    \item  \textbf{Výkonnost} - I když určité optimalizace jsou prováděny pro konkrétní systém a architekturu, výkon CLR je nižší než výkon nativního kódu. Dalším výkonnostním měřítkem je rychlost startu aplikace, která je pro CLR vyšší než v případě nativního kódu.
    \item \textbf{Operační paměť} - CLR využívá více operační paměti, jak pro aplikaci, tak i pro běhové prostředí.
    \item \textbf{Velikost aplikace} - Přítomnost CLR nehraje zásádní roli v případě monolitických aplikací, ale v případě mikroslužeb je nutné CLR přidat ke každé službě. Tímto se zvyšuje velikost jedné aplikační instance.
\end{itemize}

\n{3}{AOT}

Kompilace do nativního kódu probíhala s průběžnými problémy. Podpora ze strany knihoven 3. stran ve spoustě případů neodopvídala deklarovaným možnostem. Vývojový proces byl značně zpomalován nutností řešení problémů, které byly způsobeny nedostatečnou podporou. Experimentace s řešeními často vyústila v nutnost změny implementace, případě v implementaci zcela vlastní.

\n{4}{Výhody}

Mezi hlavní výhody se řadí zprostředkování následujícího:

\begin{itemize}
    \item  \textbf{Výkonnost} - CLR umožňuje využívat reflexi, která umožňuje získat informace o kódu za běhu aplikace. Tímto je umožněno vytvářet aplikace, které jsou schopny měnit své chování za běhu.
    \item \textbf{Paměťová zátěž} - CLR umožňuje dynamicky načítat knihovny za běhu aplikace. Tímto je umožněno vytvářet aplikace, které jsou schopny měnit své chování za běhu.
\end{itemize}

\n{4}{Nevýhody}

Zatímco za nevýhody CLR se dá považovat:

\begin{itemize}
    \item  \textbf{Absence nástrojů z CLR} - Mnoho nástrojů, které jsou dostupné v CLR, nejsou dostupné v AOT kompilaci. Mezi tyto nástroje patří například reflexe, dynamické načítání knihoven a další.
    \item \textbf{Absence dynamického načítání} - například Assembly.LoadFile.
    \item \textbf{Bez generování kódu za běhu} - například System.Reflection.Emit.
    \item \textbf{Žádné C++/CLI} - např. System.Runtime.InteropServices.WindowsRuntime
    \item \textbf{Windows: absence COM} - např. System.Runtime.InteropServices.ComTypes
    \item \textbf{Vyžaduje trimming (ořezávání)} - má určitá omezení, je však klíčový pro rozumnou velikost výsledného programu
    \item \textbf{Kompilace do jediného souboru} 
    \item \textbf{Připojení běhových knihoven} - požadované běhové knihovny jsou součástí výsledného aplikačního souboru. To zvyšuje velikost samoteného programu ve srovnání s aplikacemi závislými na frameworku.
    \item \textbf{System.Linq.Expressions} - výsledný kód používá svou interpretovanou podobu, která je pomalejší než run-time generovaný kompilovaný kód.
    \item \textbf{Kompatibilita knihoven s AOT} - né všechny knihovny runtime jsou plně anotovány tak, aby byly kompatibilní s Native AOT. To znamená, že některá varování v knihovnách runtime nejsou pro koncové vývojáře použitelná.
\end{itemize}

\n{2}{Výstup služeb}

Samotný proces nativní AOT a JIT kompilace je různě výkonnostně náročný. Při tvorbě obrazu službeb, ale i kompilace je hlavní náročná operace \emph{restore}, která stahuje potřebné závislosti a balíčky pro projekt. Proces kompilace je vysoce závislý na specifickém HW, SW a přítomnosti závislostí. Pro účely testování byly potřebné NuGet balíčky nacachovány v systému. Následující tabulka zobrazuje přehled časové náročnosti kompilace služeb pro oba kompilační cíle. K získání času výstupu bylo využity diagnostického režimu příkazu \emph{dotnet}. Pro AOT byl použit příkaz \emph{dotnet publish -v d -c Release-AOT -r osx-x64}, pro získání výstupu JIT byl použit příkaz \emph{dotnet publish -v d -c Release-JIT -r osx-x64 --self-contained false}.


\tab{Čas kompilace služeb}{tab:priklad}{0.65}{|l|c|c|r|}{
  \hline
    & JIT (s) & AOT (s) & AOT \% nárůst \\ \hline
  \emph{SRS} & 01.99 & 19.49 & 979.3 \\ \hline
  \emph{FUS} & 03.85 & 30.36 & 788.5 \\ \hline
  \emph{BPS} & 02.02 & 20.74 & 1026.7 \\ \hline
  \emph{EPS} & 01.85 & 20.05 & 1083.7 \\ \hline
}

Velikost samotného výstupního programu je dle očekávání výrazně menší v případě JIT kompilace. To je dáno tím, že výstupní program je závislý na .NET runtime, který poskytuje dodatečnou obecnou funkcionalitu a vytváří nativní kód včetně generování typů až za běhu aplikace. Následující tabulka zobrazuje velikost služeb pro oba kompilační cíle. Pro vytvoření výstupů na základě JIT byl použit příkaz \emph{dotnet publish -c Release-JIT -r osx-x64 /p:PublishSingleFile=true --self-contained false}, pro vytvoření výstupů AOT byl použit příkaz \emph{dotnet publish -c Release-JIT -r osx-x64 /p:PublishSingleFile=true --self-contained false}.

\tab{Velikost programu služeb}{tab:priklad}{0.65}{|l|c|c|r|}{
  \hline
    & JIT (MB) & AOT (MB) & AOT \% nárůst \\ \hline
  \emph{SRS} & 05.70 & 21.40 & 375.4 \\ \hline
  \emph{FUS} & 12.40 & 28.40 & 229.0 \\ \hline
  \emph{BPS} & 06.00 & 21.80 & 363.3 \\ \hline
  \emph{EPS} & 06.00 & 21.70 & 361.6 \\ \hline
}

Sestavení obrazu je závislé na přípravu prostředí, vyhodnocení a stažení závislostí, kompilaci a publikování aplikace. Výstupné obrazy jsou založené na linuxovém systému, Alpine s .NET runtime v případě JIT výstupu služby, zredukované Ubuntu v případě nativního AOT výstupu. Z pohledu použitelnosti výsledného obrazu služeb má smysl měřit velikost výstupního obrazu. Následující tabulka zobrazuje velikost obrazu služeb pro oba kompilační cíle. Použitý příkaz je \emph{docker build -t <service>:<tag> -f Dockerfile-<target> .}, kdy \emph{<target>} představuje vybranou kompilační metodu AOT nebo JIT. Před každým sestavením byl obraz a cache smazány. I přes toto opatření není zaručena konzistentní časová náročnost sestavení obrazu.

\tab{Velikost obrazu služeb}{tab:priklad}{0.65}{|l|c|c|r|}{
  \hline
    & JIT (MB) & AOT (MB) & AOT \% zmenšení \\ \hline
  \emph{SRS} & 125.63 & 31.41 & 75.0 \\ \hline
  \emph{FUS} & 143.19 & 38.32 & 73.2 \\ \hline
  \emph{BPS} & 126.50 & 31.40 & 75.2 \\ \hline
  \emph{EPS} & 126.45 & 31.74 & 74.9 \\ \hline
}

\n{3}{Vývojové prostředí}

K vývoji byl použit IDE Rider od společnosti JetBrains. Vyzkoušena byla rovněž i práce ve Visual Studio 2022 Community Edition a Visual Studio Code s doporučenými rozšířeními od Microsoft. Všechna vývojová prostředí jsou kompatibilní, co se týče procesu kompilace respektive sestavení, jelikož to se odehrává pomocí CLI .NET.

Samotný vývoj s ohledem na práci s direktivami pro různé kompilace byl značně zjednodušen vizualicemi, jenž poskytovala vývojová prostředí Rider a Visual Studio. Obdobně byla v těchto IDE zjednodušena i analýza a hledání chyb díky integraci referencí na kód generovaný na pozadí pro kompatibilitu s AOT. V tomto ohledu Visual Studio Code zaostávalo. S ohledem na aktivní vývoj a podporu, jenž je ze strany Microsoft poskytována podpoře vývoje .NET ve Visual Studio Code (po diskontuaci produktu Visual Studio pro Mac), lze očekávat, že se tato situace v budoucnu změní.

\n{3}{Knihovny třetích stran}

Pro zjednodušení procesu vývoje a využití existující funkcionality byly využity knihovny třetích stran. Následující seznam obsahuje knihovny, které byly využity použity v rámci vývoje a zda byly kompatibilní s AOT kompilací.

\begin{itemize}
  \item \textbf{Entity Framework} - Entity framework se pyšní vysokou kompatibilitou s AOT kompilací. V rámci vývoje nebyly zaznamenány problémy, avšak následné testování se ukázalo problematické. EF jakožto plnohodnotný ORM framework stopuje stav objektu a jeho změny. Toto chování bohužel vyžaduje dynamické generování kódu, což je v rozporu s možnostmi AOT kompilovaného kódu. Vypnutí této funkcionality je pouze částečné, neb EF stále vyžaduje reflexi při vkládání nových entit do databáze.
  \item \textbf{Fluent Migrator} - Fluent Migrator je knihovna, která umožňuje verzování databáze pomocí kódu. V rámci testování bylo zjištěno, že knihovna využívá reflexi pro načítání migrací. Toto chování je v rozporu s AOT kompilací a výsledkem je chyba při spuštění migrace. Problém byl vyřešen vytvořením vlastního minimalistického migrátoru, který nepoužívá reflexi.
  \item \textbf{Grpc} - Vytváření rozhrání a modelů pro gRPC komunikaci vyžadovalo využití přístupu model first. Tento přístup využívá generátorů pro tvorbu kódu, definijucího kódového rozhraní pro .NET. Tímto je dosaženo vygenerování veškerého potřebného kódu v době kompilace a je zajištěna kompatibila s AOT. Pro definici modelu code first ovšem kombatibila s AOT není zajištěna.
  \item \textbf{Párování konfigurace} - V rámci systémové .NET knihovny je umožněno volání API, jenž načte data ze sjednocení stavu proměnných prostředi a konfiguračního souboru. Součástí API je volání metody mapující tuto konfiguraci na předem definovaný objekt. Toto chování dle dostupných informací není v rozporu s AOT kompilací a volání relevantního kódu neprodukuje AOT warning. Z testování však vyplynulo, že mapování konfigurace ne objekt bylo problematické a neprobíhalo správně. Z toho důvodu je v případě AOT kompilace za pomocí deriktivy použité přímé načtení jednotlivých hodnot z konfigurace, dle stromomvého klíče.
\end{itemize}

\n{2}{Analýza testování}

Následující sekce se zabývá analýzou testovacích scénářů a výsledků testování. Testování bylo provedeno na základě předem definované metodiky. Podkladem testů byly definované scénáře, které byly vytvořeny s ohledem na funkční a nefunkční požadavky. Výsledky testování byly zaznamenány a analyzovány.

\n{3}{Scénář 1}

První scénář se zabíral jednoduchou funkcionalitou dotazu na healthcheck endpoint a meřením výkonu kestrel serveru u odpovědí na požadavky skrze REST API.
Následující výsledky představují průměrnou dobu odezvy serveru na požadavek v milisekundách. 

Na snímcích jsou zachyceny vybrané dashboardy z nástroje Grafana určené pro monitorování scénaře 1. 

Testování přineslo překvapení ve výkonnostním rozdílu, jenž byl zaznamenán mezi JIT a AOT kompilací. Výsledky byly výrazně v neprospěch AOT kompilace. Samotná rychlost serveru není v mnoha případech kritickým faktorem, avšak v případě velkého množství požadavků, může být rozdíl v řádech milisekund zásadní.

\n{3}{Scénář 2}

První scénář se zabíral jednoduchou funkcionalitou a meřením výkonu kestrel serveru a odpovědí na požadavky v REST API.

Následující výsledky představují průměrnou dobu odezvy serveru na požadavek v milisekundách. 

Na snímcích jsou zachyceny vybrané dashboardy z nástroje Grafana určené pro monitorování scénaře 1. 

Testování přineslo překvapení ve výkonnostním rozdílu, jenž byl zaznamenán mezi JIT a AOT kompilací. Výsledky byly výrazně v neprospěch AOT kompilace. Samotná rychlost serveru není v mnoha případech kritickým faktorem, avšak v případě velkého množství požadavků, může být rozdíl v řádech milisekund zásadní.

\n{3}{Scénář 3}

První scénář se zabíral jednoduchou funkcionalitou a meřením výkonu kestrel serveru a odpovědí na požadavky v REST API.

Následující výsledky představují průměrnou dobu odezvy serveru na požadavek v milisekundách. 

Na snímcích jsou zachyceny vybrané dashboardy z nástroje Grafana určené pro monitorování scénaře 1. 

Testování přineslo překvapení ve výkonnostním rozdílu, jenž byl zaznamenán mezi JIT a AOT kompilací. Výsledky byly výrazně v neprospěch AOT kompilace. Samotná rychlost serveru není v mnoha případech kritickým faktorem, avšak v případě velkého množství požadavků, může být rozdíl v řádech milisekund zásadní.

\n{3}{Scénář 4}

První scénář se zabíral jednoduchou funkcionalitou a meřením výkonu kestrel serveru a odpovědí na požadavky v REST API.

Následující výsledky představují průměrnou dobu odezvy serveru na požadavek v milisekundách. 

Na snímcích jsou zachyceny vybrané dashboardy z nástroje Grafana určené pro monitorování scénaře 1. 

Testování přineslo překvapení ve výkonnostním rozdílu, jenž byl zaznamenán mezi JIT a AOT kompilací. Výsledky byly výrazně v neprospěch AOT kompilace. Samotná rychlost serveru není v mnoha případech kritickým faktorem, avšak v případě velkého množství požadavků, může být rozdíl v řádech milisekund zásadní.

\n{3}{Scénář 5}

První scénář se zabíral jednoduchou funkcionalitou a meřením výkonu kestrel serveru a odpovědí na požadavky v REST API.

Následující výsledky představují průměrnou dobu odezvy serveru na požadavek v milisekundách. 

Na snímcích jsou zachyceny vybrané dashboardy z nástroje Grafana určené pro monitorování scénaře 1. 

Testování přineslo překvapení ve výkonnostním rozdílu, jenž byl zaznamenán mezi JIT a AOT kompilací. Výsledky byly výrazně v neprospěch AOT kompilace. Samotná rychlost serveru není v mnoha případech kritickým faktorem, avšak v případě velkého množství požadavků, může být rozdíl v řádech milisekund zásadní.

\n{2}{Závěr analýzy}

Na základě výsledků vývoje, výstupu a testování služeb lze odpovědět na definované hypotézy následujícím způsobem:

\begin{itemize}
  \item \textbf{Hypotéza 1} - Hypotéza, že vývoj služeb s jak AOT, tak JIT kompilací je v rámci podporované funkcionality systémových knihoven a ASP.NET možný s podobným API se ukázal jako ne zcela pravdivý. Při vývoji nastaly komplikace se serializací konfigurace, na které bylo nutné reagovat využitím odlišného API. Zároveň tento způsob serializace nebyl kompilátorem označen jako potencionálně problematický. Další problémy nastaly s využitím Entity Framework. Tento ORM využívá pro provádění operací nad databází tzv. tracking, který zaznamená změny nad aplikačními objekty a podle nich tvoří výsledné databázové operace. Vypnutím trackingu bylo umožněno se na datové entity dotázat a aktualizovat je. Operace vložení nové entity však bez trackingu nebyla možná. Pro knihovny 3. stran lze obecně říci, že podpora AOT kompilace není vždy úplně zřejmá a i v situacích kdy AOT varování jsou implementovány, lze očekávat chybné chování.
  \item \textbf{Hypotéza 2} - Výsledky ukazují, že služby napsané v nativním kódu se výrazněji rychleji spouští jak na hostitelských systémech, tak ve virtualizovaném prostředí. Zároveň binární velikosti samotných aplikací jsou mnohonásobně větší, než je tomu u služeb vyžadující .NET runtime. To je ovšem kompenzováno při virtualizovaném spuštění, kdy obraz služby pro vytvoření plnohodnotného kontejneru vyžaduje mnohem méně závislotí z hlediska paměti. Výsledné obrazy jsou tedy menší a rychleji spustitelné. Hypotéza byla potvrzena.
  \item \textbf{Hypotéza 3} - Na základě dostupných metrik bylo potvrzeno, že obecně služby kompilované do nativního kódu poskytují o něco horší výkon a jsou paměťově náročnější než služby kompilované do .NET runtime. Tento fakt je způsoben optimalizacemi runtime za běhu, které jsou v případě nativního kódu ztraceny. Dynamická kompilace a generování typů za běhu je náročnější než statická kompilace a generování typů při kompilaci, ale pouze při prvním použití. Rozdíl však není natolik patrný a je rychle zastíněn režií na doménovou logiku, výpočet či přístup k vzdáleným datům. Výsledky testování potvrzují hypotézu.
\end{itemize}